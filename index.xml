<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kinredon's blog</title><link>https://kinredon.github.io/</link><description>Recent content on kinredon's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 13 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://kinredon.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://kinredon.github.io/about/</link><pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate><guid>https://kinredon.github.io/about/</guid><description>&lt;p>Hugo is a static site engine written in Go.&lt;/p>
&lt;p>It makes use of a variety of open source projects including:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spf13/cobra">Cobra&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/viper">Viper&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/jWalterWeatherman">J Walter Weatherman&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/cast">Cast&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Learn more and contribute on &lt;a href="https://github.com/gohugoio">GitHub&lt;/a>.&lt;/p></description></item><item><title>参加VALSE 2021的几点总结</title><link>https://kinredon.github.io/post/valse2021/</link><pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate><guid>https://kinredon.github.io/post/valse2021/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>很幸运能有机会前往杭州参加 VALSE 2021，之前就一直关注 VALSE 的线上活动，也在线听了不少 VALSE 的 webinar，都是计算机视觉各个研究方向的优秀青年学者来做讲座。VALSE 2021 年度大会，邀请了很多大佬做 tutorial 和 workshop 的讲解，整体参与下来，也算收益良多。接下来简单聊一下我的感想并做几点总结。&lt;/p>
&lt;h2 id="几点总结">几点总结&lt;/h2>
&lt;p>&lt;strong>&lt;strong>徐宗本院士：如何突破机器学习的先验假设？&lt;/strong>&lt;/strong> 起初我只当这是一个普通的讲座，但从一开始就感受到了院士的气场，自信而不张扬，听出了其对机器学习的深刻认识，瞬间激起了我的兴趣。讲座一开始给出了一个大一统的公式指出现有机器学习范式主要包括五个部分：模型假设空间、损失函数、正则项、数据空间、优化算法，并指出了各个部分的局限性，最终针对这五个部分给出了一些解决方案，相应的探索也有些突破。很多部分之前都没听说过，但不明觉厉，这是真正的具有前瞻性的研究，令人大开眼界。&lt;/p>
&lt;p>&lt;strong>&lt;strong>迁移学习年度进展汇报&lt;/strong>&lt;/strong> 由于我的主要研究方向是迁移学习，所以我对此方向的汇报关注都比较高。之前听过张磊老师的报告，对迁移学习领域自适应方向的讲述很全面。这次年度进展汇报给予了新的惊喜，张老师给出了十个迁移学习当前的研究方向，主要如下图所示：
&lt;img src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211013000524.png" alt="">
有些工作之前关注过，但却没有进行系统的梳理，但这对整个领域的认识还是很重要的。后续有机会对每一个方向进行细致的讲述，不知道有没有人看。&lt;/p>
&lt;p>&lt;strong>&lt;strong>Vision Transformer 锋芒毕露，势不可挡&lt;/strong>&lt;/strong> 此次大会 Vision Transformer 占有很大比重，tutorial 和 workshop 都有，如香港大学罗平老师的《Vision Transformer for Object Detection and Scene Segmentation》和曹越老师的 Transformer tutorial。Vision Transformer 之前给我的感觉仅仅是计算机视觉一个新兴的研究方向，很火但还很初级，虽然听过 Swin Transformer 这样大杀器，知道重要性，但一直没有认真地关注它。此次大会发现其开始在各个领域大放异彩，如backbone网络的 VIT，CMT，Swin等，以及在各个 high level 视觉任务中的突破如检测 DETR，分割里面的 segformer 等。在视觉任务竞赛中现有很多 Top 解决方案中开始采用 Vision Transformer。本次大会让我更加地重视 Vision Transformer，锋芒毕露，势不可挡。总的来说，Vision Transformer对深度学习意义重大，大家赶快进军 Vision Transformer。&lt;a href="https://www.msra.cn/zh-cn/news/features/cv-transformer">为何Transformer在计算机视觉中如此受欢迎？&lt;/a>&lt;/p>
&lt;p>&lt;strong>&lt;strong>算力支撑起来的大规模预训练模型&lt;/strong>&lt;/strong> Google Brain 研究员翟晓华指出大规模数据、大模型、超长 training schedule 相辅相成，能够得到极好的预训练模型，大大提升模型在 finetune 后的性能，其中最受震撼的就是，同一个任务 8 张 GPU 训练一周和一个月模型的性能有较大差距，所以算力才是 yyds。&lt;/p>
&lt;p>&lt;strong>&lt;strong>下游任务的无监督表征学习&lt;/strong>&lt;/strong> 近期无监督表征学习得到广泛地研究，利用自监督方法让模型学习到更好的表征，主要包括 pretext task 和 contrastive learning。pretext task 利用数据手动创造一些标签用于给模型额外的监督信号，如旋转角度预测，patch排序，mask 预测等。contrastive learning 自 moco 以来出现了很多有意思的工作，利用对比的思想，构造正负样本对，拉近正样本对的距离，分离负样本对，实现鲁棒特征的学习。这些通过无监督表征学习的得到的特征更具判别力，在 imageNet 上进行 linear classification 的精度不断提高。然而目前这些工作对下游任务如检测、分割的提升非常有限，然而这些任务又极其重要，因此现在有很多 contrastive 的方法用于类似这样 dense prediction 任务的情况，比如 pixel-to-propagation 用来做分割。&lt;/p>
&lt;p>&lt;strong>&lt;strong>Poster &amp;amp; AI 公司&lt;/strong>&lt;/strong> 很喜欢 Poster 这一环节，可以去看自己喜欢的 paper，有问题能够直接和作者面对面交流，也能认识很多大佬。VALSE 的赞助商很多，包含国内很多优秀的 AI 公司或者实验室，直接去他们摊位交流还是很有效的。观察来看，感觉自动驾驶公司还是蛮多的，其次是各大公司的实验室，以及初创公司。大家为了抢人使出浑身解数，感觉最有效的方式就是抽奖了，这次感觉极视平台下了血本，服务器都给抽了：）就是个人运气不太好，看来永远不能成欧皇了哈哈哈。&lt;/p>
&lt;p>&lt;strong>&lt;strong>其它&lt;/strong>&lt;/strong> 这篇总结主要是在飞机上用手机凭记忆打出，听的时候没有拍照记录，所以很多细节记录不清。因此还有一些有意思的讲座上面没有提及，包括黄高老师的动态网络、崔鹏老师的OOD，stable learning，彭玺老师的 contrastive clustering 等等，希望后续 VALSE 能够 release slides，可以及时复习。其它有意思的讲座有很多，但受限于个人精力，仅看了部分的讲座。整个 VALSE 大会对我来说唯一遗憾的是，后面的 tutorial 和 workshop 没有迁移学习的 section，很多工作都穿插在了自监督和无监督的讲座里面。&lt;/p></description></item><item><title>如何利用 org mode 写博客</title><link>https://kinredon.github.io/post/org-mode-blog-configuration/</link><pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate><guid>https://kinredon.github.io/post/org-mode-blog-configuration/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>阅读本文需要一定的 emacs 和 org mode 使用基础，并阅读 &lt;a href="https://kinredon.github.io/post/how-to-publish-personal-website-on-github/">使用 Hugo 搭建个人网站（博客、个人主页）并发布到 Github 上&lt;/a> 。&lt;/p>
&lt;p>由于我经常使用 &lt;a href="https://orgmode.org/">org mode&lt;/a> 进行 gtd、项目管理、记录笔记，因此计划写文章也用 &lt;a href="https://orgmode.org/">org mode&lt;/a> 来实现。 &lt;a href="https://orgmode.org/">org mode&lt;/a> 通常基于编辑器 emac 使用，是一种类似于 markdown 的标记语言，通过简单的符号定义，得到格式化的文章效果，关于 &lt;a href="https://orgmode.org/">org mode&lt;/a> 的使用可以参考&lt;a href="https://www.cnblogs.com/open%5Fsource/archive/2011/07/17/2108747.html">Org-mode 简明手册&lt;/a>。 &lt;a href="https://orgmode.org/">org mode&lt;/a> 具有强大的文档导出功能，比如 pdf，markdown，html 等，如果你没有使用过 org mode，强烈建议学习使用。之前使用了 Hugo 搭建了个人博客，虽然 Hugo 原生支持 org mode，但是实际效果不是很理想，毕竟没有像 markdown 应用广泛。因此基本思路是用 org mode 写文章，然后转化为 markdown 文本，幸运的是 emacs 社区具有相应的支撑。&lt;/p>
&lt;p>主要使用到两个工具： &lt;code>easy-hugo&lt;/code> 和 &lt;code>ox-hugo=， =easy-hugo&lt;/code> 用来管理 Hugo 的文章， &lt;code>ox-hugo&lt;/code> 用来将 org mode 文章转化为 markdown 格式。&lt;/p>
&lt;p>关于如何使用 Hugo 搭建文章，可以查看 &lt;a href="https://kinredon.github.io/post/how-to-publish-personal-website-on-github/">使用 Hugo 搭建个人网站（博客、个人主页）并发布到 Github 上&lt;/a>。&lt;/p>
&lt;h2 id="easy-hugo-的安装与使用">easy-hugo 的安装与使用&lt;/h2>
&lt;p>查看 easy hugo 官网&lt;a href="https://github.com/masasam/emacs-easy-hugo"> emacs-easy-hugo&lt;/a>，可以发现 easy hugo 可以实现在 emac 上管理 Hugo 文章，如下图所示：&lt;/p>
&lt;link rel="stylesheet" href="https://kinredon.github.io/css/hugo-easy-gallery.css" />
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211005133605.png" alt="Figure 1: 图源：![](https://github.com/masasam/emacs-easy-hugo/blob/master/image/easy-hugo-mode.png)"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211005133605.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 1: 图源：![](https://github.com/masasam/emacs-easy-hugo/blob/master/image/easy-hugo-mode.png)&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>安装 easy hugo 通过 &lt;code>MELPA&lt;/code> ，即 &lt;code>M-x package-install easy-hugo&lt;/code> 配置如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-emacs-lisp" data-lang="emacs-lisp">&lt;span class="p">(&lt;/span>&lt;span class="nb">use-package&lt;/span> &lt;span class="nv">easy-hugo&lt;/span>
&lt;span class="nb">:init&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">easy-hugo-basedir&lt;/span> &lt;span class="s">&amp;#34;~/Documents/sync/blogs/kinredon.github.io&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">;; 网站本地文件根目录&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">easy-hugo-url&lt;/span> &lt;span class="s">&amp;#34;https://kinredon.github.io&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">;; url 路径&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">easy-hugo-sshdomain&lt;/span> &lt;span class="s">&amp;#34;kinredon.github.io&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">easy-hugo-previewtime&lt;/span> &lt;span class="s">&amp;#34;300&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">easy-hugo-default-ext&lt;/span> &lt;span class="s">&amp;#34;.org&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nb">:bind&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;C-c C-e&amp;#34;&lt;/span> &lt;span class="o">.&lt;/span> &lt;span class="nv">easy-hugo&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>利用 &lt;code>C-x C-e&lt;/code> 执行命令，然后 &lt;code>M-x easy-hugo&lt;/code> 进入博客管理界面。&lt;/p>
&lt;h2 id="ox-hugo-的安装与配置">ox-hugo 的安装与配置&lt;/h2>
&lt;p>ox-hugo 可以完美转换 org mode 到 markdown，使用 &lt;code>MeLPA&lt;/code> 安装，即 &lt;code>M-x package-install ox-hugo&lt;/code> ，配置如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-emacs-lisp" data-lang="emacs-lisp">&lt;span class="p">(&lt;/span>&lt;span class="nb">use-package&lt;/span> &lt;span class="nv">ox-hugo&lt;/span>
&lt;span class="nb">:init&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">org-hugo-base-dir&lt;/span> &lt;span class="s">&amp;#34;~/Documents/sync/blogs/kinredon.github.io&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">;; 本地网站根目录&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">setq&lt;/span> &lt;span class="nv">org-hugo-default-section-directory&lt;/span> &lt;span class="s">&amp;#34;post&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nb">:ensure&lt;/span> &lt;span class="no">t&lt;/span>
&lt;span class="nb">:after&lt;/span> &lt;span class="nv">ox&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至此，我们的配置完成，可以愉快地使用 org mode 撰写文章，自动转换到 markdown 格式，利用 hugo 生成静态网站，推送到 GitHub pages 上，也可以将 markdown 格式的文件传到其他支持 markdown 文章导入的平台，如知乎，微信公众号。&lt;/p>
&lt;p>接下来介绍一下我写文章的工作流。&lt;/p>
&lt;h2 id="工作流">工作流&lt;/h2>
&lt;p>我将 org mode 写的文章与生成的 markdown 文章分别管理，即在网站根目录添加 &lt;code>org&lt;/code> 目录：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nb">cd&lt;/span> kinredon.github.io
mkdir org
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>org&lt;/code> 目录中存储所有使用 org mode 写的文章，转化后的 markdown 文件存储在 &lt;code>./content/post&lt;/code> 目录下，利用 easy hugo 管理。由于我不想上传 org 文件，因此我在 &lt;code>.gitignore&lt;/code> 中加入 &lt;code>org&lt;/code> 让 git 忽略此文件目录下的内容。&lt;/p>
&lt;p>工作流步骤如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>撰写 org mode 文章，并存储在 &lt;code>org&lt;/code> 目录下&lt;/p>
&lt;p>用 org mode 写文章有两种方式，一种是所有文章存储在一个 org 文件里面，不同的 subtree 为一个文章，利用 org capture 新建博文，生成模板文件，然后利用 org refile 将文章保存在不同的位置，这种方式&lt;a href="https://www.xianmin.org/post/ox-hugo/">这里&lt;/a>有讲解。我采用的方式为一篇文章一个 org 文件， 我们使用 &lt;code>snippet&lt;/code> 模板, 即添加 &lt;code>snippet&lt;/code> 模板：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-emacs-lisp" data-lang="emacs-lisp">&lt;span class="err">#&lt;/span> &lt;span class="nv">-*-&lt;/span> &lt;span class="nv">mode:&lt;/span> &lt;span class="nv">snippet&lt;/span> &lt;span class="nv">-*-&lt;/span>
&lt;span class="err">#&lt;/span> &lt;span class="nv">name:&lt;/span> &lt;span class="nv">hugo&lt;/span>
&lt;span class="err">#&lt;/span> &lt;span class="nv">key:&lt;/span> &lt;span class="nv">h&lt;/span>
&lt;span class="err">#&lt;/span> &lt;span class="nv">--&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_BASE_DIR:&lt;/span> &lt;span class="nv">path-to/kinredon.github.io&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+TITLE:&lt;/span> &lt;span class="nv">$1&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+DATE:&lt;/span> &lt;span class="o">`&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">format-time-string&lt;/span> &lt;span class="s">&amp;#34;%Y-%m-%d&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">`&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_AUTO_SET_LASTMOD:&lt;/span> &lt;span class="no">t&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_TAGS:&lt;/span> &lt;span class="nv">$2&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_CATEGORIES:&lt;/span> &lt;span class="nv">$3&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_DRAFT:&lt;/span> &lt;span class="nv">false&lt;/span>
&lt;span class="err">#&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_MENU:&lt;/span> &lt;span class="nb">:menu&lt;/span> &lt;span class="s">&amp;#34;main&amp;#34;&lt;/span> &lt;span class="nb">:parent&lt;/span> &lt;span class="s">&amp;#34;docs&amp;#34;&lt;/span> &lt;span class="nb">:weight&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+options:&lt;/span> &lt;span class="nv">author:nil&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="nv">+HUGO_CUSTOM_FRONT_MATTER:&lt;/span> &lt;span class="nb">:katex&lt;/span> &lt;span class="nv">true&lt;/span>
&lt;span class="nv">$0&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>保存后，我们新建 org 文件后，输入 &lt;code>h&lt;/code> 然后使用 &lt;code>tab&lt;/code> 就可生成模板文件，如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">#+HUGO_BASE_DIR: path-to/kinredon.github.io
#+TITLE:
#+DATE: 2021-10-05
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_TAGS:
#+HUGO_CATEGORIES:
#+HUGO_DRAFT: false
# #+HUGO_MENU: :menu &amp;#34;main&amp;#34; :parent &amp;#34;docs&amp;#34; :weight 3
#+options: author:nil
#+HUGO_CUSTOM_FRONT_MATTER: :katex true
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>导出 markdown 文件， &lt;code>C-c C-e H h&lt;/code> 导出&lt;/p>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211005140343.png" />
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211005140343.png" itemprop="contentUrl">&lt;/a>
&lt;/figure>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>预览&lt;/p>
&lt;p>通过 &lt;code>M-x easy-hugo&lt;/code> 打开 easy hugo，然后选中新生成的文章，然后按 &lt;code>p&lt;/code> 即可预览生成的文章。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署&lt;/p>
&lt;p>利用 &lt;a href="https://kinredon.github.io/post/how-to-publish-personal-website-on-github/">使用 Hugo 搭建个人网站（博客、个人主页）并发布到 Github 上&lt;/a> 中的 &lt;code>deploy.sh&lt;/code> 将文章推送到远程服务器。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="cp">&lt;/span>git add .
git add org/img &lt;span class="c1"># 用来存储图像的目录，后续将会用到&lt;/span>
git commit -m &lt;span class="s2">&amp;#34;update article&amp;#34;&lt;/span>
git push
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至此，可以在远程访问个人网站啦。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="其它">其它&lt;/h2>
&lt;p>在写作过程中发现一些小问题，比如文章图片的管理，文献管理等，这里介绍一下我的解决方案，后续遇到新的问题，再持续更新。&lt;/p>
&lt;h3 id="图片管理">图片管理&lt;/h3>
&lt;p>我将图片放在 &lt;code>./org/img&lt;/code> 目录下，普通的图片直接放在该目录下，然后在 org 文件中引用即可，然而我们写文章时常常喜欢截图，每次截图后保存非常的麻烦，因此利用一个 elisp 小函数实现该功能：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-emacs-lisp" data-lang="emacs-lisp">&lt;span class="p">(&lt;/span>&lt;span class="nb">defun&lt;/span> &lt;span class="nv">my/file-paste&lt;/span> &lt;span class="p">()&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">interactive&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">let*&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="nv">org-fpath&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">buffer-file-name&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">window-buffer&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">minibuffer-selected-window&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;span class="c1">;; (dst_dpath (expand-file-name (concat (if org-fpath (file-name-base org-fpath) &amp;#34;~/Desktop/scratch&amp;#34;) &amp;#34;_&amp;#34; &amp;#34;assets&amp;#34;)))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nv">dst_dpath&lt;/span> &lt;span class="s">&amp;#34;./img&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nv">src_fpath&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">string-trim&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">shell-command-to-string&lt;/span> &lt;span class="s">&amp;#34;/Users/kinredon/Documents/Scripts/clipboard/clipboard_file.sh&amp;#34;&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nv">src_name&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">file-name-base&lt;/span> &lt;span class="nv">src_fpath&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nv">src_ext&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">file-name-extension&lt;/span> &lt;span class="nv">src_fpath&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nv">dst_fpath&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">concat&lt;/span> &lt;span class="nv">dst_dpath&lt;/span> &lt;span class="s">&amp;#34;/&amp;#34;&lt;/span> &lt;span class="nv">src_name&lt;/span> &lt;span class="s">&amp;#34;_&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">format-time-string&lt;/span> &lt;span class="s">&amp;#34;%Y%m%d%H%M%S&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="s">&amp;#34;.&amp;#34;&lt;/span> &lt;span class="nv">src_ext&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">not&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">file-exists-p&lt;/span> &lt;span class="nv">dst_dpath&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nv">make-directory&lt;/span> &lt;span class="nv">dst_dpath&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">file-exists-p&lt;/span> &lt;span class="nv">src_fpath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">progn&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">copy-file&lt;/span> &lt;span class="nv">src_fpath&lt;/span> &lt;span class="nv">dst_fpath&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nf">insert&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">concat&lt;/span> &lt;span class="s">&amp;#34;[[file:&amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">file-relative-name&lt;/span> &lt;span class="nv">dst_fpath&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">file-name-directory&lt;/span> &lt;span class="nv">org-fpath&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="s">&amp;#34;]]&amp;#34;&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nf">message&lt;/span> &lt;span class="nv">src_fpath&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="nb">use-package&lt;/span> &lt;span class="nv">org&lt;/span>
&lt;span class="nb">:ensure&lt;/span> &lt;span class="no">nil&lt;/span>
&lt;span class="nb">:mode&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;\\.org\\&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">.&lt;/span> &lt;span class="nv">org-mode&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nb">:bind&lt;/span>
&lt;span class="p">(&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;C-x C-y&amp;#34;&lt;/span> &lt;span class="o">.&lt;/span> &lt;span class="nv">my/file-paste&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 org 文件中， &lt;code>C-x C-y&lt;/code> 自动调用 &lt;code>file-paste&lt;/code> 函数，将截图自动存储在 &lt;code>img&lt;/code> 目录下，然后生成对应的引用。&lt;/p>
&lt;h3 id="文献应用">文献应用&lt;/h3>
&lt;p>由于我喜欢写论文阅读笔记，常常需要应用文献，关于文献管理，我使用的 &lt;code>org-ref&lt;/code> 统一管理在一个 &lt;code>reference.bib&lt;/code> 文件里，但是发现 &lt;code>org-ref&lt;/code> 对 &lt;code>ox-hugo&lt;/code> 似乎不太支持，因此使用 &lt;code>citeproc-org&lt;/code> 进行简单的配置即可正常到处参考文献，如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-emacs-lisp" data-lang="emacs-lisp">&lt;span class="p">(&lt;/span>&lt;span class="nv">citeproc-org-setup&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;; 可以将其写入配置文件中，或执行&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在相应位置中插入参考文献，调用 &lt;code>M-x org-ref-helm-insert-cite-link&lt;/code> 即可，导出文章即可以看到参考文献成功导出。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/54705090">Emacs Org-mode学术写作&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.xianmin.org/post/ox-hugo/">博客写作流程之工具篇： emacs, orgmode, hugo &amp;amp; ox-hugo&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://q3yi.me/post/build-blog-with-orgmode-hugo-and-github-pages/">使用orgmode+hugo+github pages搭建博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zlearning.netlify.app/linux/emacs/emacs-hugo-academic.html">使用Emacs和Hugo academic主题&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>使用 Hugo 搭建个人网站（博客、个人主页）并发布到 Github 上</title><link>https://kinredon.github.io/post/how-to-publish-personal-website-on-github/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>https://kinredon.github.io/post/how-to-publish-personal-website-on-github/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>相信很多人都有搭建个人网站的需求，可能是想写自己的博文，传达一些思想给社区。也有可能你是一名科研工作者，需要搭建个人学术主页展示科研成果。我也或多或少出于以上原因，选择搭建了个人网站，搭建过程中出现了许多问题，因此记录和分享，避免下次踩坑。Anyway，本文记录使用搭建个人博客的全过程，包括网站工具 &lt;a href="https://gohugo.io/">Hugo&lt;/a> 的介绍和使用设置，以及如何将个人网站发布在免费托管平台，也就是 GitHub Pages 上。&lt;/p>
&lt;p>我选择 Hugo 的原因主要有三点：&lt;/p>
&lt;ul>
&lt;li>简单易用；&lt;/li>
&lt;li>&lt;a href="https://gohugo.io/">Hugo&lt;/a> 能够快速地构建个人网站；&lt;/li>
&lt;li>拥有丰富的主题，可供挑选 &lt;a href="https://jamstackthemes.dev/ssg/hugo/">Hugo Themes&lt;/a>；&lt;/li>
&lt;/ul>
&lt;p>选择 GitHub Pages 的原因就更简单了，免费又好用。&lt;/p>
&lt;h2 id="hugo-的安装和使用">Hugo 的安装和使用&lt;/h2>
&lt;p>Hugo 宣传号称是世界上最快构建网站的框架，也是最流行的静态网站生成工具之一。&lt;/p>
&lt;h3 id="安装-hugo">安装 Hugo&lt;/h3>
&lt;p>由于我的操作系统是 MacOs 因此安装起来特别简单：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">brew install hugo
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其他平台可参考 &lt;a href="https://gohugo.io/getting-started/installing">Hugo Install&lt;/a>。&lt;/p>
&lt;h3 id="创建个人网站">创建个人网站&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">hugo new site quickstart
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="使用-hugo-主题">使用 Hugo 主题&lt;/h3>
&lt;p>我使用的是 &lt;a href="https://github.com/xianmin/hugo-theme-jane">jane&lt;/a>, 将主题 &lt;code>clone&lt;/code> 到 &lt;code>theme&lt;/code> 目录下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nb">cd&lt;/span> quickstart
git clone https://github.com/xianmin/hugo-theme-jane.git --depth&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> themes/jane
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用示例文本和默认的站点设置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">cp -r themes/jane/exampleSite/content ./
cp themes/jane/exampleSite/config.toml ./
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>启动 Hugo 服务器，在 &lt;a href="http://localhost:1313/">http://localhost:1313/&lt;/a> 将会看到示例 jane 主题的示例网站：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">hugo server
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="个人配置和网站生成">个人配置和网站生成&lt;/h3>
&lt;p>配置文件在网站根目录 &lt;code>quickstart&lt;/code> 下 &lt;code>config.toml&lt;/code> , 根据自身需求进行修改。在 jane 主题下的 &lt;code>exampleSite&lt;/code> 文件夹中的文件可作为参考。默认的文章将存储在 &lt;code>./content/post&lt;/code> 中，每当写完文章，运行 &lt;code>hugo&lt;/code> 命令，Hugo 将自动生成静态网站到 &lt;code>public&lt;/code> 文件夹中，我们只需要将该文件夹的内容发布在网络上即可。&lt;/p>
&lt;p>更多关于主题的配置可以参考 &lt;a href="https://github.com/xianmin/hugo-theme-jane/blob/master/README-zh.md">jane README.md&lt;/a>。&lt;/p>
&lt;h2 id="github-pages">GitHub Pages&lt;/h2>
&lt;p>我个人经常使用 GitHub，也见到很多大佬利用 GitHub pages 挂载自己的个人网站，发现配置起来也很简单，因此选择使用 GitHub pages 来进行配置，关于 GitHub pages 可以查看&lt;a href="https://pages.github.com/">官网&lt;/a>，主要包括四个步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建一个与 &lt;code>username&lt;/code> 同名的 &lt;strong>空&lt;/strong> &lt;code>username.github.io&lt;/code> 仓库，不包含任何内容，如 &lt;code>readme.md=，比如我的用户名为 =kinredon&lt;/code>, 因此我创建了一个仓库，名为 &lt;code>kinredon.github.io&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>克隆仓库到本地&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">git clone https://github.com/kinredon/kinredon.github.io
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>添加个人网站内容到该仓库&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="c1"># copy 生成的网站内容到仓库文件夹下&lt;/span>
cp -rf quickstart/public/* kinredon.github.io/
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>将文件内容同步更新到 GitHub 服务器上&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="nb">cd&lt;/span> kinredon.github.io
git add .
git commit -m &lt;span class="s2">&amp;#34;init the website&amp;#34;&lt;/span>
git push
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时，通过进入 &lt;a href="https://kinredon.github.io">https://kinredon.github.io&lt;/a> 即可访问自己的个人网站。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>上面的步骤略显麻烦，每次需要将生成在 &lt;code>public&lt;/code> 文件夹下的目录拷贝到 &lt;code>kinredon.github.io&lt;/code> 目录下，然后发布到远程服务器。根据 &lt;a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">Host on GitHub&lt;/a>，发布到 GitHub Pages 有两种方式, 一种是直接使用仓库目录下的 &lt;code>doc&lt;/code> 目录作为原本 &lt;code>public&lt;/code> 目录，详情可以参考 &lt;a href="https://patrolli.github.io/xssq/post/hugo%5F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">hugo 博客搭建&lt;/a>。我采用的方式是利用 GitHub Action 自动完成上述过程。&lt;/p>
&lt;h3 id="使用-github-action-自动发布文章">使用 GitHub Action 自动发布文章&lt;/h3>
&lt;p>这里主要参考 &lt;a href="https://vinurs.me/posts/1a329bf3-fbb7-4006-9714-d3b072826376/">搭建个人blog&lt;/a>, 使用 &lt;code>master&lt;/code> 分支发布文章，使用一个新的 &lt;code>source&lt;/code> 分支进行写作，写作完成后上传 &lt;code>source&lt;/code> ，GitHub Action 自动将 &lt;code>source&lt;/code> 分支的 &lt;code>publish&lt;/code> 文件夹拷贝到 &lt;code>master&lt;/code> 分支，从而完成文章的发布。&lt;/p>
&lt;p>主要步骤如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 GitHub 上的个人网站仓库 &lt;code>kinredon.github.io&lt;/code> 新建 &lt;code>source&lt;/code> 分支&lt;/p>
&lt;link rel="stylesheet" href="https://kinredon.github.io/css/hugo-easy-gallery.css" />
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211004154805.png" alt="Figure 1: 创建 source 分支，由于我已经创建过，所以这里以 source-1 为例"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211004154805.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 1: 创建 source 分支，由于我已经创建过，所以这里以 source-1 为例&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>清除文件夹 &lt;code>kinredon.github.io&lt;/code> 中的内容，并将个人网站 &lt;code>quickstart&lt;/code> 中的所有内容 copy 到 &lt;code>kinredon.github.io&lt;/code> ：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">git clone --branch&lt;span class="o">=&lt;/span>&lt;span class="nb">source&lt;/span> https://github.com/kinredon/kinredon.github.io.git
rm -rf kinredon.github.io/*
cp -rf quickstart/* kinredon.github.io
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>生成 &lt;code>ACTIONS_DEPLOY_KEY&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">ssh-keygen -t rsa -b &lt;span class="m">4096&lt;/span> -C &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>git config user.email&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -f gh-pages -N &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将生成的私钥文件 &lt;code>gh-pages&lt;/code> (注意不是公钥 &lt;code>gh-pages.pub&lt;/code>) 中的内容复制填写到 GitHub 仓库设置中，即在 &lt;code>kinredon.github.io&lt;/code> 项目主页中，找到 Repository Settings -&amp;gt; Secrets -&amp;gt; 添加这个私钥的内容并命名为 &lt;code>ACTIONS_DEPLOY_KEY&lt;/code> 。
然后在 &lt;code>kinredon.github.io&lt;/code> 项目主页中，找到 Repository Settings -&amp;gt; Deploy Keys -&amp;gt; 添加这个公钥的内容，命名为 &lt;code>ACTIONS_DEPLOY_KEY&lt;/code> ，并勾选 Allow write access。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置 workflow&lt;/p>
&lt;p>创建 workflow 文件&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">mkdir -p .github/workflows/
touch .github/workflows/main.yml
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 &lt;code>main.yaml&lt;/code> 中撰写 workflow，内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">name: github pages
on:
push:
branches:
​ - &lt;span class="nb">source&lt;/span>
jobs:
build-deploy:
runs-on: ubuntu-18.04
steps:
​ - uses: actions/checkout@master
​ - name: Checkout submodules
shell: bash
run: &lt;span class="p">|&lt;/span>
&lt;span class="nv">auth_header&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>git config --local --get http.https://github.com/.extraheader&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
git submodule sync --recursive
git -c &lt;span class="s2">&amp;#34;http.extraheader=&lt;/span>&lt;span class="nv">$auth_header&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -c protocol.version&lt;span class="o">=&lt;/span>&lt;span class="m">2&lt;/span> submodule update --init --force --recursive --depth&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
- name: Setup Hugo
uses: peaceiris/actions-hugo@v2
with:
hugo-version: &lt;span class="s1">&amp;#39;latest&amp;#39;&lt;/span>
extended: &lt;span class="nb">true&lt;/span>
- name: Build
run: hugo --gc --minify --cleanDestinationDir
- name: Deploy
uses: peaceiris/actions-gh-pages@v3
with:
deploy_key: &lt;span class="si">${&lt;/span>&lt;span class="p">{ secrets.ACTIONS_DEPLOY_KEY &lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="o">}&lt;/span>
publish_dir: ./public
publish_branch: main
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，如果你的仓库是 &lt;code>master&lt;/code> 分支作为主分支，将 &lt;code>publish_branch&lt;/code> 后面的 &lt;code>main&lt;/code> 修改为 &lt;code>master&lt;/code> ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 source 分支发送到远程&lt;/p>
&lt;p>发送脚本 &lt;code>deploy.sh&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="cp">#!/bin/bash
&lt;/span>&lt;span class="cp">&lt;/span>git add .
git commit -m &lt;span class="s2">&amp;#34;update article&amp;#34;&lt;/span>
git push
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>推送到远程分支：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">sh deploy.sh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>推送成功后，可以在项目主页中的 action 里面查看自动部署是否成功，即 &lt;a href="https://github.com/kinredon/kinredon.github.io/actions">https://github.com/kinredon/kinredon.github.io/actions&lt;/a>；&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>半监督目标检测（Semi-Supervised Object Detection，SSOD）相关方法介绍</title><link>https://kinredon.github.io/post/semi-supervised-object-detection/</link><pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate><guid>https://kinredon.github.io/post/semi-supervised-object-detection/</guid><description>&lt;p>近期阅读了一些半监督目标检测（Semi-Supervised Object Detection，SSOD）的文章，特此总结，以供未来查阅。&lt;/p>
&lt;h2 id="什么是半监督目标检测">什么是半监督目标检测？&lt;/h2>
&lt;p>传统机器学习根据训练数据集中的标注情况，有着不同的场景，主要包括：监督学习、弱监督学习、弱半监督学习、半监督学习。由于目标检测任务的特殊性，在介绍半监督目标检测方法之前，我们查看一下目标检测在这四个方向下的具体设定，如下图所示（不包括无监督学习）：&lt;/p>
&lt;link rel="stylesheet" href="https://kinredon.github.io/css/hugo-easy-gallery.css" />
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205549.png" alt="Figure 1: 图一 目标检测的不同的 setting"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205549.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 1: 图一 目标检测的不同的 setting&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>总而言之，我们可以讲目标检测的 setting 分为四个部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>有监督目标检测&lt;/strong> ：拥有大规模带标签的数据，包括完整的实例级别的标注，即包含坐标和类别信息；&lt;/li>
&lt;li>&lt;strong>弱监督目标检测&lt;/strong> ：数据集中的标注仅包含类别信息，不包含坐标信息，如图一 b 所示；&lt;/li>
&lt;li>&lt;strong>弱半监督目标检测&lt;/strong> ：数据集中拥有部分实例级别的标注，大量弱标注数据，模型希望利用大规模的弱标注数据提升模型的检测能力；&lt;/li>
&lt;li>&lt;strong>半监督目标检测&lt;/strong> ：数据集中拥有部分实例级别的标注，大量未标注数据，模型希望利用大规模的无标注的数据提升模型的检测能力；&lt;/li>
&lt;/ul>
&lt;p>半监督目标检测方法的核心在于，如何充分利用大量未标注、多样性的数据提升模型在测试集上的性能，目前的半监督目标检测方法主要有两个方向：&lt;/p>
&lt;ol>
&lt;li>一致性学习（Consistency based Learning）&lt;/li>
&lt;li>伪标签（Pseudo-label based Learning）&lt;/li>
&lt;/ol>
&lt;p>前者利用两个深度卷积神经网络学习同一张 unlabeled 图像不同扰动（比如水平翻转，不同的对比度，亮度等）之间的一致性，充分利用 unlabeled data的信息。后者利用在 labeled data 上学习的预训练模型对 unlabeled data 进行推理，经过 NMS 后减少大量冗余框后，利用一个阈值去挑选伪标签，最后利用伪标签训练模型。个人认为这两种方法没有本质的区别，本身都是伪标签技术，一致性学习可以认为是一种 soft pseudo label，而后者是一种 hard pseudo label。&lt;/p>
&lt;p>接下来我讲介绍几篇近期半监督目标检测文章，主要发表在 ICLR, NeurIPS, CVPR等会议。&lt;/p>
&lt;h2 id="consistency-based-semi-supervised-learning-for-object-detection-neurips-19">Consistency-based Semi-supervised Learning for Object Detection, NeurIPS 19&lt;/h2>
&lt;p>CSD 这篇文章是比较早期的半监督目标检测方法，非常简单，该文章提出了一个 Consistency-based 半监督目标检测算法，可以同时在单阶段和双阶段检测器上工作。&lt;/p>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205728.png" alt="Figure 2: 图二 CSD 半监督目标检测算法结构图"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205728.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 2: 图二 CSD 半监督目标检测算法结构图&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>CSD 的结构如图二所示，以单阶段目标检测器为例，训练的损失函数主要包括两个部分，labeled sample 的监督损失和 unlabeled samples 的 Consistency loss。针对 unlabeled samples，首先将图像水平翻转，然后分别送入网络当中，得到对应的 Feature map，由于两张翻转的图像的空间位置是可以一一对应的，因此可以在对应的位置计算一致性损失。分类部分，利用 JS 散度作为 consistency loss；定位部分，利用 L2 loss 作为 consistency loss。&lt;/p>
&lt;p>双阶段检测器的部分与单阶段检测器类似，差别主要在于 RPN（Region Proposal Network） 对于不同的输入可能产生不同的 proposals，因此在计算 consistency loss 时无法一一对应。解决此问题也很简单，两张图像使用同一个 RPN 生成同一组 RoI (Region of Interest) 来提取特征得到 proposals。&lt;/p>
&lt;p>作者还提出了一个 Background elimination 方法来消除大量背景部分的损失主导训练过程的问题，因此作者定义了一个 mask 来过滤大量的背景样本：
\[
m^{k}=\left\{\begin{array}{ll}1, &amp;amp; \text { if } \operatorname{argmax}\left(f_{c l s}^{k}(I)\right) \neq b a c k g r o u n d \ 0, &amp;amp; \text { otherwise }\end{array}\right.
\]
其中，当该实例的类别不等于背景类时等于1，否则为 0。&lt;/p>
&lt;h2 id="a-simple-semi-supervised-learning-framework-for-object-detection">A Simple Semi-Supervised Learning Framework for Object Detection&lt;/h2>
&lt;p>STAC 提出了一个基于 hard pseudo label 的半监督目标检测算法，如图三所示，该方法包含四个步骤：&lt;/p>
&lt;ol>
&lt;li>首先利用 labeled data 训练一个 Teacher 模型；&lt;/li>
&lt;li>生成 pseudo label, 将 unlabeled data 输入进 Teacher 网络中，得到大量的目标框预测结果，利用 NMS 消除大量的冗余框，最后使用阈值来挑选高置信度的 pseudo label；&lt;/li>
&lt;li>应用 strong data augmentation。得到 pseudo label 后与 unlabeled image 图像相结合，包括图像级别的颜色抖动、geometric transformation(平移、旋转、剪切)、box-level transformation（小幅度的平移、旋转、剪切）；&lt;/li>
&lt;li>计算无监督 loss （pseudo label）和监督学习 loss；&lt;/li>
&lt;/ol>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205743.png" alt="Figure 3: 图三 STAC 半监督目标检测算法示意图"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205743.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 3: 图三 STAC 半监督目标检测算法示意图&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;h2 id="instant-teaching-an-end-to-end-semi-supervised-object-detection-framework">Instant-Teaching: An End-to-End Semi-Supervised Object Detection Framework&lt;/h2>
&lt;p>Instant-Teaching 主要的 motivation 在于 STAC 仅生成一次的 pseudo label，即离线生成，在训练的过程中不会更新。这样的模式存在一个问题是，当训练的模型精度逐步提升，超过原本的模型，继续使用原来模型生成的 pseudo label 会限制模型精度进一步提升。因此作者提出 Instant-Teaching，以及 Instant-Teaching*。&lt;/p>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205807.png" alt="Figure 4: 图四 Instant-Teaching 和 Instant-Teaching\* 示意图"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205807.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 4: 图四 Instant-Teaching 和 Instant-Teaching\* 示意图&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>Instant-Teaching 采用即时生成 pseudo label 的模式，在每一个迭代中，包括两个步骤：&lt;/p>
&lt;ol>
&lt;li>生成 pseudo label: 对 unlabeled image 进行 weak augmentation，送入模型中得到 hard label；&lt;/li>
&lt;li>利用生成的 pseudo label 进行 strong augmentation，除了 在 STAC 中的数据增强，还包括了 Mixup 和 Mosaic，利用增强后的数据训练模型；&lt;/li>
&lt;/ol>
&lt;p>Instant-Teaching 主要提出了一个 co-rectify scheme 来解决 pseudo label 的 confirmation bias 的问题（噪声 pseudo label 的错误累计效应）。因此，作者利用两个模型，给予不同的初始化参数，输入不同的数据增强的样本，分别彼此纠正和检测对方生成的 pseudo label，形式如图四右半部分。&lt;/p>
&lt;h2 id="data-uncertainty-guided-multi-phase-learning-for-semi-supervised-object-detection">Data-Uncertainty Guided Multi-Phase Learning for Semi-Supervised Object Detection&lt;/h2>
&lt;p>这篇工作提出一个多阶段的学习半监督目标检测学习算法,前面的方法基本在伪标签生成后，直接拟合生成的伪标签，这样将会引发 label noise overfitting 问题，即由于深度网络较强的拟合能力，即时错误的标签模型也能够拟合。因此作者利用图像级别 uncertainty 来进行多阶段学习，思想类似于课程学习（curriculum learning），先学习 easy 样本再学习 difficult data。具体来说，作者利用 RPN 出来的 proposal 的平均分数作为 uncertainty 的指标。平均分数越高，uncertainty 越小，视为 easy sample，反之为 difficult sample。&lt;/p>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205821.png" alt="Figure 5: 图五 DUGMPL示意图"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205821.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 5: 图五 DUGMPL示意图&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>在区域级别，作者提出 RoI 的 re-weighting 操作，作者从 Soft sampling for robust object detection 得到启示，对于具有噪声的数据（伪标签），在训练时，不同的 RoI 应该给予不同的权重，作者提出了几个的简单但有效的策略来解决这个问题，受限于篇幅，这里不再具体介绍，感兴趣可以去阅读原文的 Section 3.3.2.&lt;/p>
&lt;h2 id="unbiased-teacher-for-semi-supervised-object-detection">Unbiased Teacher for Semi-Supervised Object Detection&lt;/h2>
&lt;p>这篇文章发表在 ICLR 2021， 主要思想还是说现在的半监督目标检测算法生成的标签具有 bias，这里作者主要 argue 的点在于目标检测中存在天然的类别不平衡问题，包括 RPN 前景和背景的分类，ROIHead 的多类别分类，因此作者提出了一个 Unbiased Teacher 方法，来解决此问题。&lt;/p>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205832.png" alt="Figure 6: 图六 Unbiased Teacher 示意图"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205832.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 6: 图六 Unbiased Teacher 示意图&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>从方法上来说，非常的简单，首先是 Burn-IN stage，即在 labeled data 上训练一个预训练模型，然后利用 Mean Teacher 的结构，Teacher 生成 Pseudo label 来同时监督 RPN 和 ROIHead。不同的点在于，作者只利用 pseudo label 更新 RPN 和 ROIHead 的 classification 分支，主要原因在于由 confidence score 生成的 pseudo label 与 bounding box 位置的质量关系不大。除此之外，作者将原本的 cross entropy loss 替换为 Focal loss 来解决 pseudo label bias 问题，即 class imbalance。&lt;/p>
&lt;h2 id="interactive-self-training-with-mean-teachers-for-semi-supervised-object-detection">Interactive Self-Training with Mean Teachers for Semi-supervised Object Detection&lt;/h2>
&lt;p>这篇文章揭示了之前利用 pseudo label 的方法忽略了*同一张图片在不同的迭代的检测结果之间的差异性*，而且不同的模型对同一张图像的检测结果也有差异。&lt;/p>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205846.png" alt="Figure 7: 图七 不同迭代的模型对同一张图像的预测结果(a)(b),不同 ROIHead 的检测结果"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205846.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 7: 图七 不同迭代的模型对同一张图像的预测结果(a)(b),不同 ROIHead 的检测结果&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>因此作者提出一个基于 Mean Teacher 的 Interactive form of self-training 的半监督目标检测算法：&lt;/p>
&lt;ol>
&lt;li>解决不同训练迭代检测结果的不稳定问题，作者使用 NMS 将不同迭代的检测结果进行融合。&lt;/li>
&lt;li>同时利用两个检测头部 ROIHead 生成 pseudo label，两个检测头部可以相互提供有用的互补信息。&lt;/li>
&lt;/ol>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205855.png" alt="Figure 8: 图八 Interactive Self-Training 的算法步骤"/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205855.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 8: 图八 Interactive Self-Training 的算法步骤&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;p>IST 算法的主要步骤如图八所示：&lt;/p>
&lt;ul>
&lt;li>使用 labeled data 训练一个拥有两个 ROIHead 的预训练模型;&lt;/li>
&lt;li>利用预训练模型生成两个对应的伪标签;&lt;/li>
&lt;li>利用 labeled data 和 unlabeled data 进行监督学习，图八中 Pseudo Labels Memory 用来使用 NMS 融合不同迭代的检测结果。该步骤详情如图九所示，利用 Mean Teacher 的结构，teacher 生成 pseudo label 并与 Memory 中的 pseudo label 进行融合，并更新 Memory。作者使用 Dropblock 模块确保不同的 ROIHead 能够独立收敛，并提供互补的信息，即图九中的 D。&lt;/li>
&lt;/ul>
&lt;div class="box">
&lt;figure itemprop="associatedMedia"
itemscope itemtype="http://schema.org/ImageObject" >
&lt;div class="img">
&lt;img itemprop="thumbnail" src="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205905.png" alt="Figure 9: 图九 Illustration of interactive self-training with mean teachers."/>
&lt;/div>
&lt;a href="https://kinredon.github.io/ox-hugo/pngpaste_clipboard_file_20211003205905.png" itemprop="contentUrl">&lt;/a>
&lt;figcaption>
&lt;p>Figure 9: 图九 Illustration of interactive self-training with mean teachers.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;/div>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了一些半监督目标检测算法，即如何利用大量的 unlabeled data 提升模型的检测性能，当前主要的方法包含 consistency based 以及 pseudo label based 两类。consistency based 方法主要学习模型在 unlabeled data 上的一致性，pseudo label 则利用在 unlabeled data 上生成 pseudo label 进而监督模型训练，主要的方向即为如何生成高质量的伪标签以及模型如何对抗在 unlabeled data 上的 noise label。本文介绍了的半监督目标检测方法不多，关于方法的介绍较为笼统，如有谬误，烦请指正，其中细节，还需仔细阅读文章，欢迎讨论。&lt;/p></description></item></channel></rss>